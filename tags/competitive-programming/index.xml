<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Competitive programming on BedirTapkan</title>
    <link>https://bedirt.github.io/tags/competitive-programming/</link>
    <description>Recent content in Competitive programming on BedirTapkan</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 01 Feb 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://bedirt.github.io/tags/competitive-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Counting Sort</title>
      <link>https://bedirt.github.io/posts/blog_posts/counting_sort/</link>
      <pubDate>Wed, 01 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://bedirt.github.io/posts/blog_posts/counting_sort/</guid>
      <description>One of the most efficient sorting algorithms</description>
      <content:encoded><![CDATA[<p>Counting sort is a nice in-place sorting algorithm that we can use for sorting instantly. (This is mostly used for competitive programming.) What I meant by this is, we can use counting sort when we are getting the input. This will not get any additional cost for us, and really good technique for using in-place sorting. I&rsquo;ll get there after explaining the algorithm.</p>
<!-- raw HTML omitted -->
<h3 id="complexity-">Complexity ?</h3>
<hr>
<p>Let me tell you the complexity if you are wondering, but I will explain &ldquo;why&rdquo; after the algorithm itself. <strong>O(n+k)</strong> : n , is size of the array that we will sort and k is the maximum element we have.</p>
<h3 id="algorithm">Algorithm</h3>
<hr>
<p>OK. Let&rsquo;s think of an array. For the sake of simplicity, let&rsquo;s make it short&hellip;</p>
<pre><code>      myArray = [2, 3, 7, 4, 3, 9]
</code></pre>
<p>We have an array -unsorted- , minimum number is <strong>2</strong>, maximum is <strong>9</strong> and we have <strong>6</strong> elements in the array. Alright so let&rsquo;s think of one more array. Which is from 0 (array starting point) to our maximum number (9) and all the values are initially <strong>0</strong>.</p>
<pre><code>      INDEXES    0  1  2  3  4  5  6  7  8  9
weAreCounting = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p><strong>ATTENTION!</strong> We are going to iterate over first array one by one, and we will increment the values that we have (i.e. for first step it is myArray[0] which is 2 so go to weAreCounting array and increment [2] by 1):</p>
<pre><code>for i in myArray:
    weAreCounting[i] += 1
</code></pre>
<p>NOW WHAT WE HAVE AT THE END OF THIS LOOP?</p>
<pre><code>      INDEXES    0  1  2  3  4  5  6  7  8  9
weAreCounting = [0, 0, 1, 2, 1, 0, 0, 1, 0, 1]
</code></pre>
<p>So weAreCounting array basically shows us how many of these numbers we do have (i.e. we have 2 threes so weAreCounting[3] = 2).</p>
<p>This part is how you have all the items counted. Now we can use this as sorted array (with iterating over it) or we can have our new array that will have the sorted array directly. For the second version:</p>
<p>My logic will be to use same array before (myArray) so that it will be more efficient (space-wise).</p>
<p>So I iterate thorough weAreCounting and if the number is bigger than 0 I will add it into myArray. That is all of the logic.</p>
<h3 id="code">Code</h3>
<hr>
<p>Here is the c++ code, as simplified as possible. ENJOY!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-0-1"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-1"> 1</a>
</span><span class="lnt" id="hl-0-2"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-2"> 2</a>
</span><span class="lnt" id="hl-0-3"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-3"> 3</a>
</span><span class="lnt" id="hl-0-4"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-4"> 4</a>
</span><span class="lnt" id="hl-0-5"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-5"> 5</a>
</span><span class="lnt" id="hl-0-6"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-6"> 6</a>
</span><span class="lnt" id="hl-0-7"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-7"> 7</a>
</span><span class="lnt" id="hl-0-8"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-8"> 8</a>
</span><span class="lnt" id="hl-0-9"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-9"> 9</a>
</span><span class="lnt" id="hl-0-10"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-10">10</a>
</span><span class="lnt" id="hl-0-11"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-11">11</a>
</span><span class="lnt" id="hl-0-12"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-12">12</a>
</span><span class="lnt" id="hl-0-13"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-13">13</a>
</span><span class="lnt" id="hl-0-14"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-14">14</a>
</span><span class="lnt" id="hl-0-15"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-15">15</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">countingSort</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">countingArray</span><span class="p">[</span><span class="n">MAX_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">countingArray</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">output_Index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUM</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span> <span class="n">countingArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span> <span class="p">)</span> <span class="c1">// Process will continue until the elements reach to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">arr</span><span class="p">[</span><span class="n">output_Index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// PS: Incrementing will be after the line_process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Instead of these two lines we could use memset function too...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>And here is python3.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-1-1"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-1"> 1</a>
</span><span class="lnt" id="hl-1-2"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-2"> 2</a>
</span><span class="lnt" id="hl-1-3"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-3"> 3</a>
</span><span class="lnt" id="hl-1-4"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-4"> 4</a>
</span><span class="lnt" id="hl-1-5"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-5"> 5</a>
</span><span class="lnt" id="hl-1-6"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-6"> 6</a>
</span><span class="lnt" id="hl-1-7"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-7"> 7</a>
</span><span class="lnt" id="hl-1-8"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-8"> 8</a>
</span><span class="lnt" id="hl-1-9"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-9"> 9</a>
</span><span class="lnt" id="hl-1-10"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-10">10</a>
</span><span class="lnt" id="hl-1-11"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-11">11</a>
</span><span class="lnt" id="hl-1-12"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-12">12</a>
</span><span class="lnt" id="hl-1-13"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-13">13</a>
</span><span class="lnt" id="hl-1-14"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-14">14</a>
</span><span class="lnt" id="hl-1-15"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-15">15</a>
</span><span class="lnt" id="hl-1-16"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-16">16</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">countingSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">countingArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">countingArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">countingArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">            <span class="n">countingArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">countingSort</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">,</span><span class="mi">5</span> <span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If you check the complexity in the code, you will see that we have two loops, one is doing n operation (going through the array that we will sort). Second loop is doing k operation (which is the maximum number that we have in the array that we will sort). So time complexity will be O(n+k).</p>
<p>The space complexity: we have two arrays (we could have 3 but we decrease it to 3 because we used the one at the beginig two times. Since at the end we will not going to need that one.) one is size of n and one is size of k so our complexity will be O(n+k).</p>
<p>Now I suggest you to go to the link below, and try to solve the questions in Week 3/ Counting Sort section. So that you will have full understanding about this question. If you like the concept of it you can star or watch out repository as well. Have a great one!</p>
<p><a href="https://github.com/NAU-ACM/ACM-ICPC-Preparation">You can also find other algorithms explained and full code samples about this one here</a> (Check Week 3)</p>]]></content:encoded>
    </item>
    
    <item>
      <title>Factorizing a Number</title>
      <link>https://bedirt.github.io/posts/blog_posts/prime_factorization/</link>
      <pubDate>Sun, 20 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://bedirt.github.io/posts/blog_posts/prime_factorization/</guid>
      <description>Prime numbers are really important, how do we find them though?</description>
      <content:encoded><![CDATA[<p><strong>Before starting-</strong> What is Prime Factorization ? What is a Prime number ? If you are curious about these please checkout this link before proceed because I will not explain them here :)</p>
<p><a href="https://en.wikipedia.org/wiki/Prime_number">Wikipedia - Prime Numbers</a></p>
<p>Since we all know what a prime number and composite number is, let&rsquo;s look at our realllly simple algorithm. Actually there is nothing fancy here, we are just using simple Sieve of Eratoshenes(Hardest name to pronounce, I checked online if I am right) algorithm. By the way that topic also pre-requised for this post, but fortunetely we already have a tutorial-explanation for it. If you don&rsquo;t know or confused about it in some ways please check the links below:</p>
<p><a href="https://github.com/BedirT/ACM-ICPC-Preparation/tree/master/Week01">Some sources to learn about Sieve of Eretosthenes</a></p>
<p>Since &ldquo;WE&rdquo; covered everything required, let me involve in this learning process too&hellip; Prime factorization: This is highly important topic. All your passwords , your bank accounts and stuff are protected by these numbers. Anyway that is why we actually have couple algorithms about Prime Factorization. There is a good answer on <a href="quora.com">quora.com</a> about the prime number algorithms:</p>
<blockquote>
<p>Different algorithms get used based on how large the number is. It goes something like this:</p>
<p>Small Numbers : Use simple sieve algorithms to create list of primes and do plain factorization. Works blazingly fast for small numbers.</p>
<p>Big Numbers : Use Pollard&rsquo;s rho algorithm, Shanks&rsquo; square forms factorization (Thanks to Dana Jacobsen for the pointer)</p>
<p>Less Than  10^25  : Use Lenstra elliptic curve factorization</p>
<p>Less Than  10^100  : Use Quadratic sieve</p>
<p>More Than  10^100  : Use General number field sieve</p>
<p>Currently, in the very large integer factorization arena, GNFS is the leader. It was the winner of the RSA factoring challenge of the 232 digit number</p>
<p><em>Arun Iyer</em> <a href="https://www.quora.com/Which-is-the-fastest-prime-factorization-algorithm-to-date">quora.com</a></p>
</blockquote>
<p>OK cool, we have a lot of options, although you can see that these numbers are gigantic. $10^{25}$ ?? This was the smallest one mentioned above by the way. So we don&rsquo;t really care about them, they are exist because like I said before, these numbers are extremely powerful so people need biiig ones. Since our languages supports (for C++) until $10^{19}$ , and our tutorials are for ACM-ICPC kind programming contests, considering that these contests have time limit and %100 sure that if $10^{25}$ will given&hellip; you probably should search for some trick in question, because we cannot compete that many operations on time.</p>
<h2 id="finally-the-algorithm">Finally the Algorithm</h2>
<p>Anyway after all explanation lets talk about our &ldquo;small&rdquo; algorithm. It really is nothing much than using Sieve algorithm. We are just going to optimize it a little bit. Let&rsquo;s say we already runned our sieve function:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-0-1"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-0-1">1</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">sieve</span><span class="p">(</span><span class="mi">10001</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now we have an array or vector , I don&rsquo;t know how you implemented so I will go with mine -&gt; you can check it out:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-1-1"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-1"> 1</a>
</span><span class="lnt" id="hl-1-2"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-2"> 2</a>
</span><span class="lnt" id="hl-1-3"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-3"> 3</a>
</span><span class="lnt" id="hl-1-4"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-4"> 4</a>
</span><span class="lnt" id="hl-1-5"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-5"> 5</a>
</span><span class="lnt" id="hl-1-6"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-6"> 6</a>
</span><span class="lnt" id="hl-1-7"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-7"> 7</a>
</span><span class="lnt" id="hl-1-8"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-8"> 8</a>
</span><span class="lnt" id="hl-1-9"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-9"> 9</a>
</span><span class="lnt" id="hl-1-10"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-10">10</a>
</span><span class="lnt" id="hl-1-11"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-11">11</a>
</span><span class="lnt" id="hl-1-12"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-1-12">12</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">primes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sieve</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">bitset</span><span class="o">&lt;</span><span class="mi">10000010</span><span class="o">&gt;</span> <span class="n">was</span><span class="p">;</span> 	<span class="c1">// You can also use boolean array or vector, but this is optimized for bool (C++ is best :) )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">was</span><span class="p">.</span><span class="n">set</span><span class="p">();</span>        		<span class="c1">// Initilizing all bitset to true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">was</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">was</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// Except 0 and 1 of course 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">  		<span class="k">if</span> <span class="p">(</span><span class="n">was</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  			<span class="n">primes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	    		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span> <span class="n">was</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  		<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We have a vector named primes and it has all the primes from begining(2) to size.</p>
<p>$$primes -&gt; [ 2 , 3 , 5 , 7 , 11 , 13 , 19 , 21 , &hellip; ]$$</p>
<p>What will we do is we will use basic logic and check every prime number and if it can divide our number <strong>N</strong>. If it can divide , we will just put it into our new vector (If you don&rsquo;t know vector you still can use list or array, depends on the language). If we can divide we will divide it, with this way we will decrement our operations. So let&rsquo;s say we have <strong>18</strong> as our <strong>N</strong>. We start with first element in the <strong><em>primes</em></strong> which is <strong>2</strong>.</p>
<ul>
<li>Is <strong>2</strong> dividing <strong>N = 18</strong> ?</li>
</ul>
<p>Yes obviously so:</p>
<ul>
<li>Put <strong>2</strong> into our <strong>Factors</strong> vector;</li>
</ul>
<p>So -&gt;</p>
<p>$$Factors -&gt; [ 2 ]$$</p>
<p>And we will divide our N by 2:</p>
<ul>
<li><strong>N = 18/2 = 9</strong></li>
</ul>
<p>Continue to check if 2 is dividing N which is not becuese <strong>N = 9</strong>. So lets pass 2 and go to 3:</p>
<ul>
<li>Is <strong>3</strong> dividing <strong>N = 9</strong> ? Yes</li>
<li>Put <strong>3</strong> into our <strong>Factors</strong> vector;</li>
</ul>
<p>$$Factors -&gt; [ 2 , 3 ]$$</p>
<ul>
<li><strong>N = 9/3 = 3</strong></li>
<li>Is <strong>3</strong> dividing <strong>N = 3</strong> ? Yes</li>
<li>Put <strong>3</strong> into our <strong>Factors</strong> vector;</li>
</ul>
<p>$$Factors -&gt; [ 2 , 3 , 3 ]$$</p>
<ul>
<li><strong>N = 3/3 = 1</strong></li>
<li>Is <strong>3</strong> dividing <strong>N = 1</strong> ? Nope</li>
<li>Proceed to <strong>5</strong>.</li>
</ul>
<p><strong>5</strong> ? Yes we will stop here. This is the next optimization, at most we will go until $p^2 \leq N$ (and p is my prime number that I am checking). This is what determines my complexity in this method. So I have $\sqrt{N}$ here. This is also my number that will go into O notation -&gt; O($\sqrt{N}$). (Mathematically this complexity is represented with $O(\pi(\sqrt{N})) = O(\sqrt{N}\times lnN)$)You can further check the code C++ implementation. I commented it so you can see what is going on in each step. After understanding the code I highly recommend you to solve questions about this topic, we have our list for this question as well, check the link at the bottom.</p>
<h2 id="implementation-c">Implementation C++</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-2-1"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-1"> 1</a>
</span><span class="lnt" id="hl-2-2"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-2"> 2</a>
</span><span class="lnt" id="hl-2-3"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-3"> 3</a>
</span><span class="lnt" id="hl-2-4"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-4"> 4</a>
</span><span class="lnt" id="hl-2-5"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-5"> 5</a>
</span><span class="lnt" id="hl-2-6"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-6"> 6</a>
</span><span class="lnt" id="hl-2-7"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-7"> 7</a>
</span><span class="lnt" id="hl-2-8"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-8"> 8</a>
</span><span class="lnt" id="hl-2-9"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-9"> 9</a>
</span><span class="lnt" id="hl-2-10"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-10">10</a>
</span><span class="lnt" id="hl-2-11"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-11">11</a>
</span><span class="lnt" id="hl-2-12"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-12">12</a>
</span><span class="lnt" id="hl-2-13"><a style="outline: none; text-decoration:none; color:inherit" href="#hl-2-13">13</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">primeFactors</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vc</span><span class="p">;</span> <span class="c1">// An empty vector for us to fill with our numbers factors.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span> <span class="c1">// f standing for FACTOR - idx is index that we will increment 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">while</span><span class="p">(</span><span class="n">N</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">N</span> <span class="o">&gt;=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">f</span><span class="p">){</span>  <span class="c1">// f * f ... This is the part with sqrt(N) so the loop continues until our factor is bigger than sqrt(N)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">while</span><span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> 	<span class="c1">// I will continuously check if N is divisible by this prime, until it become wrong.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">N</span> <span class="o">/=</span> <span class="n">f</span><span class="p">;</span> 			<span class="c1">// Dividing N to my prime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">vc</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> 	<span class="c1">// adding that prime to my vector.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">N</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">vc</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">N</span><span class="p">);</span> 	<span class="c1">// This case is for prime numbers itself, if the number is prime than we should add it to our vector. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">// If some value, after our loop is still not equals to 1 than it is a prime itself. (because of sqrt(N))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="n">vc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We have a well designed Curriculum on Github, also the questions about this algorithm are there too, check it out here</p>
<p><a href="https://github.com/BedirT/ACM-ICPC-Preparation">ACM-ICPC Curriculum</a></p>]]></content:encoded>
    </item>
    
    <item>
      <title>Kadane&#39;s Algorithm</title>
      <link>https://bedirt.github.io/posts/blog_posts/kadane/</link>
      <pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://bedirt.github.io/posts/blog_posts/kadane/</guid>
      <description>How to find sum of maximum of the subarrays</description>
      <content:encoded><![CDATA[<p>What we will learn today is, how to find the , in optimal solution. First, let&rsquo;s clarify the goal a bit.</p>
<p>What is subarray? Subarray is an array that is included in the bigger array. So if we have an array that has 7 elements in it. What we have is elements that have indexes of: 0, 1, 2, 3, 4, 5, 6 . A subarray is smaller array inside of this big array. So for example 1, 2, 3  or 4, 5 are subarrays. But 1, 3 is not a subarray because the subarray should be contiguous. So our task is to find the largest contiguous array in our big array.</p>
<p><img loading="lazy" src="/posts/blog_posts/kadane/images/not_subarray.jpg" type="" alt=""  /></p>
<p>Since we clarify our objective let&rsquo;s look at the solutions we have. First let&rsquo;s see what will be the brute force solution since that will be the first one which comes to mind. What we would do is, we would start from 0 index and hold it, check every elements before that index and keep the largest one. So if we have [3, 5, 7, 9] in the array. We would first check the 3. We would see that it is the largest subarray since there is none other than that. And than we would check the index 1 -&gt; 5, we have 5 and 5 + 3 = 8. The bigger one is 8 so we keep 8. Than we go for 2nd index -&gt; 7. We have 7, 7+5, 7+5+3 so that biggest one will be 7+5+3 which is 15, we keep it. Then next one : index 3 -&gt; 9. We have 9, 9+7, 9+7+5, 9+7+5+3. Largest one will be 9+7+5+3 = 24. So we compare the ones we found as sum of subarrays and the greatest one will be 24, the last one we checked, that&rsquo;s because we have no negative elements in the array. Anyways that would be the brute force solution and still a smart one. But the time complexity would be O(n^2). Since we take the index and check every others that we can combine with this index. Let me visualize this one:</p>
<p><img loading="lazy" src="/posts/blog_posts/kadane/images/bruteForce.jpg" type="" alt=""  /></p>
<p>OK, we got this part. So we got the question, now what is the optimal solution for this problem. What is this guy , <a href="https://en.wikipedia.org/wiki/Joseph_Born_Kadane">Kadane</a> , found. Here is the algorithm then. This algorithm is dynamic, which means we will approach the result using the ones we find before. OK, this guy teaches us a way that has complexity O(n), linear time.</p>
<p>Let&rsquo;s go with an example so it will be more clear. Our array is [5, -2, -4, 4, 4]. Kadane says that in each iteration we have only two options to get the max subarray:</p>
<ol>
<li>It can be only itself</li>
<li>It can be itself combined with the maximum subarray that previous index has.</li>
</ol>
<p>Man, this is a smart solution. OK, what he says is let&rsquo;s say we calculated the sum of maximum subarrays until index 1 which has value -2. For the sake of understanding let&rsquo;s calculate with brute force. We have -2 and -2+5. The greater one is -2+5 = 3. So let&rsquo;s proceed. This time let&rsquo;s use Kadane&rsquo;s Algorithm for calculating the 3rd step. What are the options:</p>
<ol>
<li>It can be only itself (We have -4 as the 2nd indexed value so = <strong>-4</strong>)</li>
<li>It can be itself combined with the maximum subarray that previous index has. (We have 3 as 1st index&rsquo;s max Subarray sum, so = <strong>3-4</strong> = <strong>-1</strong>)</li>
</ol>
<p>So we have a -1 and -4 &hellip; -1 indeed. But is it always the second option then? Let&rsquo;s see with another part of our array. Let&rsquo;s proceed one more step. Don&rsquo;t forget that we have -1 as our current max. 3rd index -&gt;</p>
<ol>
<li>It can be only itself (We have 4 as the value = <strong>4</strong>)</li>
<li>It can be itself combined with the maximum subarray that previous index has. (We have -1 as the previous index&rsquo;s maximum -&gt; <strong>-1+4=3</strong>)</li>
</ol>
<p>Now we approached the first option, 4 &gt; 3 so we will keep 4 instead of 3. And repeat this until the end &hellip; Really that&rsquo;s all.</p>
<p><img loading="lazy" src="/posts/blog_posts/kadane/images/kadaneTable.jpg" type="" alt=""  /></p>
<p>Now that we understand the logic. Let&rsquo;s proceed to the code. I will give pseudocode here.</p>
<pre><code>kadane(Array){

    generalMaximum = currentMaximum = Array[0]

    for (i = 1 until n) {
        currentMaximum = maximum of(Array[i], currentMaximum + Array[i]);
        if(currentMaximum &gt;= generalMaximum) generalMaximum = currentMaximum;
    }

    return generalMaximum;

}
</code></pre>
<p>If you are interested on learning or practicing more algorithms, you can visit our curriculum from github <a href="https://github.com/NAU-ACM/ACM-ICPC-Preparation">ACM-ICPC Preparation</a>. There are also questions and source code&rsquo;s about this topic. ENJOY!</p>]]></content:encoded>
    </item>
    
  </channel>
</rss>
